
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Writing a Basic FIR Filter in C (2) &#8212; Sam G Notes</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/basic_mod.css?v=0.7.0-1" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <script src="../_static/js/petite-vue.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Writing a Basic FIR Filter in C (1)" href="fir_filter_in_c_1.html" /> 
  </head><body data-dark_mode_code_blocks="true">

<div id="top_nav">
    

    <nav>
        
            
        

        <p id="toggle_sidebar">
            <a href="#" title="Toggle sidebar">|||</a>
        </p>
        <h1><a href="../index.html" title="Go to homepage">Sam G Notes</a></h1>

        <a id="mode_toggle" href="#" @click.prevent="handleClick" :title="mode">
    <template v-if="mode == 'light'">
        <svg width="100%" height="100%" viewBox="0 0 79 80" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="mode_light"><rect id="Bounds" x="0" y="-0" width="78.623" height="79.049" style="fill:none;"/><circle cx="39.311" cy="39.524" r="15.734" style="fill:#fff;"/><g id="beams"><g id="beam"><path id="beam1" serif:id="beam" d="M44.212,4.901c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.9,2.196 -4.9,4.901l-0,9.614c-0,2.705 2.196,4.901 4.9,4.901c2.705,0 4.901,-2.196 4.901,-4.901l0,-9.614Z" style="fill:#fff;"/></g><g id="beam2" serif:id="beam"><path id="beam3" serif:id="beam" d="M67.48,18.073c1.913,-1.912 1.913,-5.018 0,-6.931c-1.912,-1.912 -5.018,-1.912 -6.931,0l-6.798,6.799c-1.912,1.912 -1.912,5.018 0,6.931c1.913,1.912 5.018,1.912 6.931,-0l6.798,-6.799Z" style="fill:#fff;"/></g><g id="beam4" serif:id="beam"><path id="beam5" serif:id="beam" d="M25.728,61.108c1.912,-1.913 1.912,-5.018 -0,-6.931c-1.913,-1.913 -5.019,-1.913 -6.931,-0l-6.799,6.798c-1.912,1.913 -1.912,5.019 0,6.931c1.913,1.913 5.019,1.913 6.931,0l6.799,-6.798Z" style="fill:#fff;"/></g><g id="beam6" serif:id="beam"><path id="beam7" serif:id="beam" d="M60.682,54.177c-1.913,-1.913 -5.018,-1.913 -6.931,-0c-1.912,1.913 -1.912,5.018 0,6.931l6.798,6.798c1.913,1.913 5.019,1.913 6.931,0c1.913,-1.912 1.913,-5.018 0,-6.931l-6.798,-6.798Z" style="fill:#fff;"/></g><g id="beam8" serif:id="beam"><path id="beam9" serif:id="beam" d="M4.901,34.623c-2.705,0 -4.901,2.196 -4.901,4.901c0,2.705 2.196,4.901 4.901,4.901l9.614,0c2.705,0 4.901,-2.196 4.901,-4.901c0,-2.705 -2.196,-4.901 -4.901,-4.901l-9.614,0Z" style="fill:#fff;"/></g><g id="beam10" serif:id="beam"><path id="beam11" serif:id="beam" d="M44.212,64.534c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.9,2.196 -4.9,4.901l-0,9.614c-0,2.705 2.196,4.901 4.9,4.901c2.705,-0 4.901,-2.196 4.901,-4.901l0,-9.614Z" style="fill:#fff;"/></g><g id="beam12" serif:id="beam"><path id="beam13" serif:id="beam" d="M18.929,11.142c-1.912,-1.912 -5.018,-1.912 -6.931,0c-1.912,1.913 -1.912,5.019 0,6.931l6.799,6.799c1.912,1.912 5.018,1.912 6.931,-0c1.912,-1.913 1.912,-5.019 -0,-6.931l-6.799,-6.799Z" style="fill:#fff;"/></g><g id="beam14" serif:id="beam"><path id="beam15" serif:id="beam" d="M64.108,34.623c-2.705,0 -4.901,2.196 -4.901,4.901c-0,2.705 2.196,4.901 4.901,4.901l9.614,0c2.705,0 4.901,-2.196 4.901,-4.901c-0,-2.705 -2.196,-4.901 -4.901,-4.901l-9.614,0Z" style="fill:#fff;"/></g></g></g></svg>
    </template>

    <template v-if="mode == 'dark'">
        <svg width="100%" height="100%" viewBox="0 0 79 80" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="mode_dark"><rect id="Bounds" x="0" y="-0" width="78.623" height="79.049" style="fill:none;"/><circle cx="39.311" cy="39.524" r="15.734" style="fill:#fff;"/><g id="beams"><g id="beam"><path id="beam1" serif:id="beam" d="M44.212,14.515c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,0 -4.901,2.196 -4.901,4.901c0,2.705 2.197,4.901 4.901,4.901c2.705,0 4.901,-2.196 4.901,-4.901Z" style="fill:#fff;"/></g><g id="beam2" serif:id="beam"><path id="beam3" serif:id="beam" d="M60.662,24.892c1.902,-1.902 1.902,-4.99 0,-6.892l-0.04,-0.039c-1.901,-1.902 -4.989,-1.902 -6.891,-0c-1.901,1.901 -1.901,4.989 0,6.891l0.04,0.04c1.902,1.901 4.989,1.901 6.891,-0Z" style="fill:#fff;"/></g><g id="beam4" serif:id="beam"><path id="beam5" serif:id="beam" d="M25.732,61.103c1.91,-1.91 1.91,-5.011 0,-6.921l-0.009,-0.01c-1.91,-1.91 -5.012,-1.91 -6.921,-0c-1.91,1.91 -1.91,5.011 -0,6.921l0.01,0.01c1.909,1.91 5.011,1.91 6.92,-0Z" style="fill:#fff;"/></g><g id="beam6" serif:id="beam"><path id="beam7" serif:id="beam" d="M60.672,54.167c-1.907,-1.907 -5.004,-1.907 -6.911,0l-0.02,0.02c-1.907,1.907 -1.907,5.004 0,6.911c1.907,1.907 5.004,1.907 6.911,-0l0.02,-0.02c1.907,-1.907 1.907,-5.004 0,-6.911Z" style="fill:#fff;"/></g><g id="beam8" serif:id="beam"><path id="beam9" serif:id="beam" d="M14.52,34.623c-2.702,0 -4.896,2.194 -4.896,4.896l0,0.01c0,2.702 2.194,4.896 4.896,4.896c2.702,0 4.896,-2.194 4.896,-4.896l-0,-0.01c-0,-2.702 -2.194,-4.896 -4.896,-4.896Z" style="fill:#fff;"/></g><g id="beam10" serif:id="beam"><path id="beam11" serif:id="beam" d="M44.212,64.534c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.901,2.196 -4.901,4.901c0,2.704 2.197,4.9 4.901,4.9c2.705,0 4.901,-2.196 4.901,-4.9Z" style="fill:#fff;"/></g><g id="beam12" serif:id="beam"><path id="beam13" serif:id="beam" d="M25.73,17.943c-1.911,-1.911 -5.015,-1.911 -6.926,0l-0.005,0.005c-1.911,1.911 -1.911,5.015 0,6.926c1.911,1.911 5.015,1.911 6.926,0l0.005,-0.005c1.911,-1.911 1.911,-5.014 -0,-6.926Z" style="fill:#fff;"/></g><g id="beam14" serif:id="beam"><path id="beam15" serif:id="beam" d="M64.098,34.623c-2.699,0 -4.891,2.192 -4.891,4.892l-0,0.019c-0,2.699 2.192,4.891 4.891,4.891c2.7,0 4.892,-2.192 4.892,-4.891l0,-0.019c0,-2.7 -2.192,-4.892 -4.892,-4.892Z" style="fill:#fff;"/></g></g></g></svg>
    </template>

    <template v-if="mode == 'darkest'">
        <svg width="100%" height="100%" viewBox="0 0 79 80" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g id="mode_darkest"><rect id="Bounds" x="0" y="-0" width="78.623" height="79.049" style="fill:none;"/><path d="M39.315,23.791c8.684,-0 15.734,7.05 15.734,15.733c0,8.684 -7.05,15.734 -15.734,15.734c-8.683,0 -15.733,-7.05 -15.733,-15.734c-0,-8.683 7.05,-15.733 15.733,-15.733Zm0,4.737c6.069,0 10.997,4.927 10.997,10.996c-0,6.069 -4.928,10.996 -10.997,10.996c-6.068,0 -10.996,-4.927 -10.996,-10.996c0,-6.069 4.928,-10.996 10.996,-10.996Z" style="fill:#fff;"/><g id="beams"><g id="beam"><path id="beam1" serif:id="beam" d="M44.216,14.515c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,0 -4.9,2.196 -4.9,4.901c-0,2.705 2.196,4.901 4.9,4.901c2.705,0 4.901,-2.196 4.901,-4.901Z" style="fill:#fff;"/></g><g id="beam2" serif:id="beam"><path id="beam3" serif:id="beam" d="M60.666,24.892c1.902,-1.902 1.902,-4.99 0,-6.892l-0.04,-0.039c-1.901,-1.902 -4.989,-1.902 -6.891,-0c-1.901,1.901 -1.901,4.989 0,6.891l0.04,0.04c1.902,1.901 4.99,1.901 6.891,-0Z" style="fill:#fff;"/></g><g id="beam4" serif:id="beam"><path id="beam5" serif:id="beam" d="M25.737,61.103c1.909,-1.91 1.909,-5.011 -0,-6.921l-0.01,-0.01c-1.91,-1.91 -5.011,-1.91 -6.921,-0c-1.91,1.91 -1.91,5.011 -0,6.921l0.01,0.01c1.91,1.91 5.011,1.91 6.921,-0Z" style="fill:#fff;"/></g><g id="beam6" serif:id="beam"><path id="beam7" serif:id="beam" d="M60.676,54.167c-1.907,-1.907 -5.004,-1.907 -6.911,0l-0.02,0.02c-1.907,1.907 -1.907,5.004 0,6.911c1.907,1.907 5.004,1.907 6.911,-0l0.02,-0.02c1.907,-1.907 1.907,-5.004 0,-6.911Z" style="fill:#fff;"/></g><g id="beam8" serif:id="beam"><path id="beam9" serif:id="beam" d="M14.524,34.623c-2.702,0 -4.896,2.194 -4.896,4.896l0,0.01c0,2.702 2.194,4.896 4.896,4.896c2.702,0 4.896,-2.194 4.896,-4.896l0,-0.01c0,-2.702 -2.194,-4.896 -4.896,-4.896Z" style="fill:#fff;"/></g><g id="beam10" serif:id="beam"><path id="beam11" serif:id="beam" d="M44.216,64.534c0,-2.705 -2.196,-4.901 -4.901,-4.901c-2.704,-0 -4.9,2.196 -4.9,4.901c-0,2.704 2.196,4.9 4.9,4.9c2.705,0 4.901,-2.196 4.901,-4.9Z" style="fill:#fff;"/></g><g id="beam12" serif:id="beam"><path id="beam13" serif:id="beam" d="M25.734,17.943c-1.911,-1.911 -5.015,-1.911 -6.926,0l-0.005,0.005c-1.911,1.911 -1.911,5.015 0,6.926c1.911,1.911 5.015,1.911 6.926,0l0.005,-0.005c1.911,-1.911 1.911,-5.014 0,-6.926Z" style="fill:#fff;"/></g><g id="beam14" serif:id="beam"><path id="beam15" serif:id="beam" d="M64.103,34.623c-2.7,0 -4.892,2.192 -4.892,4.892l-0,0.019c-0,2.699 2.192,4.891 4.892,4.891c2.699,0 4.891,-2.192 4.891,-4.891l0,-0.019c0,-2.7 -2.192,-4.892 -4.891,-4.892Z" style="fill:#fff;"/></g></g></g></svg>
    </template>
</a>

<script>
(function() {
    const LOCAL_STORAGE_KEY = 'piccoloThemeMode'

    var initialMode = localStorage.getItem(LOCAL_STORAGE_KEY)

    if (initialMode) {
        // Make sure the value in local storage is valid
        if (['light', 'dark', 'darkest'].indexOf(initialMode) == -1) {
            initialMode = 'light'
            localStorage.setItem(LOCAL_STORAGE_KEY, initialMode)
        }
    } else {
        // Check if the client prefers dark mode
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            initialMode = 'dark'
        } else {
            initialMode = 'light'
        }
        localStorage.setItem(LOCAL_STORAGE_KEY, initialMode)
    }

    document.documentElement.dataset.mode = initialMode

    PetiteVue.createApp({
        'mode': initialMode,
        handleClick() {
            let currentMode = this.mode

            if (currentMode == 'light') {
                this.mode = 'dark'
            } else if (currentMode == 'dark') {
                this.mode = 'darkest'
            } else if (currentMode == 'darkest') {
                this.mode = 'light'
            }

            document.documentElement.dataset.mode = this.mode
            localStorage.setItem(LOCAL_STORAGE_KEY, this.mode)

            console.log(this.mode)
        }
    }).mount('#mode_toggle')
})()
</script>
            <p class="mobile_search_link">
                <a href="../search.html" title="Search">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 65 64" fill-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2">
                        <path d="M14.873 40.009c-2.315-3.943-3.642-8.532-3.642-13.429C11.231 11.91 23.141 0 37.811 0s26.58 11.91 26.58 26.58-11.91 26.58-26.58 26.58a26.44 26.44 0 0 1-14.277-4.161L9.739 62.794a3.12 3.12 0 0 1-4.413 0L.913 58.382c-1.217-1.218-1.217-3.196 0-4.413l13.96-13.96zM37.811 8.054c10.225 0 18.526 8.301 18.526 18.526s-8.301 18.526-18.526 18.526-18.526-8.301-18.526-18.526S27.586 8.054 37.811 8.054z" fill="#fff" />
                    </svg>
                </a>
            </p>
        

        <div class="searchbox_wrapper">
            
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
    </nav>
</div>

    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../linux_gaming.html">Linux Gaming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../embedded_notes.html">Embedded Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language_notes/language_notes.html">Programming Language Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Software/Software.html">Software Notes</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="dsp.html">DSP Notes</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="fir_filter_in_c_1.html">Writing a Basic FIR Filter in C (1)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Writing a Basic FIR Filter in C (2)</a></li>
</ul>
</li>
</ul>

        </div>
      </div>


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="writing-a-basic-fir-filter-in-c-2">
<h1>Writing a Basic FIR Filter in C (2)<a class="headerlink" href="#writing-a-basic-fir-filter-in-c-2" title="Permalink to this heading">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h2>
<p>In the previous article on writing a FIR filter in C I mentioned that there were
a few optimizations which could be made to the code. In this section I will
discuss these and who how the code can be improved.</p>
</section>
<section id="speed-optimizations">
<h2>Speed optimizations<a class="headerlink" href="#speed-optimizations" title="Permalink to this heading">¶</a></h2>
<p>The biggest flaw with the previous implementation is the shifting of the
<code class="code docutils literal notranslate"><span class="pre">buffer</span></code> array in the <code class="code docutils literal notranslate"><span class="pre">FIR_Stream_Mem</span></code> struct after every sample is
processed. This is done by re-writing every element of the buffer, as shown in
the following table:</p>
<table class="docutils align-default" id="id1">
<caption><span class="caption-text">Changes to <code class="code docutils literal notranslate"><span class="pre">FIR_Stream_Mem-&gt;buffer</span></code></span><a class="headerlink" href="#id1" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 10.7%" />
<col style="width: 89.3%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Sample</p></th>
<th class="head"><p><code class="code docutils literal notranslate"><span class="pre">buffer</span></code> Contents</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>N</p></td>
<td><p>7 6 5 4 3 2 1 0</p></td>
</tr>
<tr class="row-odd"><td><p>N + 1</p></td>
<td><p>8 7 6 5 4 3 2 1</p></td>
</tr>
<tr class="row-even"><td><p>N + 2</p></td>
<td><p>9 8 7 6 5 4 3 2</p></td>
</tr>
</tbody>
</table>
<p>This means that we are doing <code class="code docutils literal notranslate"><span class="pre">FIR_Stream_Mem-&gt;tap_len</span></code> writes to memory in
order to update the buffer. However, only one of the values in <code class="code docutils literal notranslate"><span class="pre">buffer</span></code>
has actually changed, the others have just shifted position. By changing the
start position of the buffer, we can reduce the number of writes to only one
per sample. The table below shows this in action, where the bolded positions are
the start of the array.</p>
<table class="docutils align-default" id="id2">
<caption><span class="caption-text">Optimized <code class="code docutils literal notranslate"><span class="pre">FIR_Stream_Mem-&gt;buffer</span></code> memory layout</span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 10.7%" />
<col style="width: 89.3%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Sample</p></th>
<th class="head"><p><code class="code docutils literal notranslate"><span class="pre">buffer</span></code> Contents</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>N</p></td>
<td><p><strong>7</strong> 6 5 4 3 2 1 0</p></td>
</tr>
<tr class="row-odd"><td><p>N + 1</p></td>
<td><p>7 6 5 4 3 2 1 <strong>8</strong></p></td>
</tr>
<tr class="row-even"><td><p>N + 2</p></td>
<td><p>7 6 5 4 3 2 <strong>9</strong> 8</p></td>
</tr>
</tbody>
</table>
<p>To implement this method we first need to modify the <code class="code docutils literal notranslate"><span class="pre">FIR_Stream_Mem</span></code>
struct to record the starting position of <code class="code docutils literal notranslate"><span class="pre">buffer</span></code> :</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">FIR_Stream_Mem</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">tap_len</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">taps</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">buffer_start</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">FIR_Stream_Mem</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="code docutils literal notranslate"><span class="pre">buffer_start</span></code> value should also be initialized to 0 in
<code class="code docutils literal notranslate"><span class="pre">init_fir_stream</span></code>:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">FIR_Stream_Mem</span><span class="w"> </span><span class="o">*</span><span class="nf">init_fir_stream</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">taps</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">tap_len</span><span class="p">){</span>
<span class="w">    </span><span class="cm">/* Create the output object in memory */</span>
<span class="w">    </span><span class="n">FIR_Stream_Mem</span><span class="w"> </span><span class="o">*</span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">FIR_Stream_Mem</span><span class="o">*</span><span class="p">)(</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">FIR_Stream_Mem</span><span class="p">)));</span>

<span class="w">    </span><span class="cm">/* Copy the taps across */</span>
<span class="w">    </span><span class="n">output</span><span class="o">-&gt;</span><span class="n">tap_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tap_len</span><span class="p">;</span>
<span class="w">    </span><span class="n">output</span><span class="o">-&gt;</span><span class="n">taps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)(</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">tap_len</span><span class="p">));</span>
<span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="n">output</span><span class="o">-&gt;</span><span class="n">taps</span><span class="p">,</span><span class="w"> </span><span class="n">taps</span><span class="p">,</span><span class="w"> </span><span class="n">tap_len</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>

<span class="w">    </span><span class="cm">/* Set the buffer to all zeros */</span>
<span class="w">    </span><span class="n">output</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="o">*</span><span class="p">)(</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">tap_len</span><span class="p">));</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">output</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="n">tap_len</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>

<span class="w">    </span><span class="cm">/* Set the buffer start position to 0 */</span>
<span class="w">    </span><span class="n">output</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, we need to modify <code class="code docutils literal notranslate"><span class="pre">apply_fft</span></code> to loop index and update
<code class="code docutils literal notranslate"><span class="pre">buffer</span></code> correctly. We loop though <code class="code docutils literal notranslate"><span class="pre">buffer</span></code> when applying the filter
taps, so we make out first mod here. Rather than using the for-loop index, we
calculate our own index using the following algorithm:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">size_t</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">tap_len</span><span class="p">){</span>
<span class="w">    </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">tap_len</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This ensures we don’t get an out-of-bounds error by looping the index back to
the start if it will otherwise overrun.</p>
<p>We also need to ensure that <code class="code docutils literal notranslate"><span class="pre">buffer</span></code> gets updated correctly. This is done
by setting the value at <code class="code docutils literal notranslate"><span class="pre">buffer_start</span></code> to be our current input sample,
then subtracting one from <code class="code docutils literal notranslate"><span class="pre">buffer_start</span></code>. We again avoid an overrun by
checking if <code class="code docutils literal notranslate"><span class="pre">buffer_start</span></code> is 0, in which case we set <code class="code docutils literal notranslate"><span class="pre">buffer_start</span></code>
to be the last element in the array. This is done using the following code:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="k">if</span><span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">tap_len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This gives a final <code class="code docutils literal notranslate"><span class="pre">apply_fft</span></code> function of:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">apply_fir</span><span class="p">(</span><span class="n">FIR_Stream_Mem</span><span class="w"> </span><span class="o">*</span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">){</span>
<span class="w">    </span><span class="cm">/* Loop through all input samples */</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="w">        </span><span class="cm">/* Calculate first output sample */</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">sample_output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">taps</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="w">        </span><span class="cm">/* Loop through all the taps */</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">tap_len</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
<span class="w">            </span><span class="kt">size_t</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span>

<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">tap_len</span><span class="p">){</span>
<span class="w">                </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">tap_len</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">sample_output</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">taps</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* Update buffer */</span>
<span class="w">        </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">            </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">tap_len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">buffer_start</span><span class="o">--</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sample_output</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="speed-boost">
<h3>Speed Boost<a class="headerlink" href="#speed-boost" title="Permalink to this heading">¶</a></h3>
<p>Modern compilers are pretty good at optimizing the code given to them, so does
this modification actually give a noticeable speed increase? To test this we can
use the following function which calls <code class="code docutils literal notranslate"><span class="pre">apply_fft</span></code> 1,000,000 times and
compare the execution times between the two implementations:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;time.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;assert.h&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;fir_filter.h&quot;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">randfrom</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">min</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">max</span><span class="p">){</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">min</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">div</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RAND_MAX</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">range</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">rand</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">div</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="cm">/* Seed random number generator */</span>
<span class="w">    </span><span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>

<span class="w">    </span><span class="cm">/* Create some random input data */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>

<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">randfrom</span><span class="p">(</span><span class="mf">-1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* Create random taps */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">taps</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">};</span>

<span class="w">    </span><span class="cm">/* Init fir filter */</span>
<span class="w">    </span><span class="n">FIR_Stream_Mem</span><span class="w"> </span><span class="o">*</span><span class="n">fir_filter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">init_fir_stream</span><span class="p">(</span><span class="n">taps</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Filter data */</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">output</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="w">        </span><span class="n">apply_fir</span><span class="p">(</span><span class="n">fir_filter</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">output</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* Deallocate the FIR memory */</span>
<span class="w">    </span><span class="n">deinit_fir</span><span class="p">(</span><span class="n">fir_filter</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Running the code with the unoptimized <code class="code docutils literal notranslate"><span class="pre">apply_fft</span></code> took 25.936 seconds,
whereas the optimized version took only 22.511 seconds.</p>
</section>
</section>
<section id="memory-optimizations">
<h2>Memory optimizations<a class="headerlink" href="#memory-optimizations" title="Permalink to this heading">¶</a></h2>
<p>As modern computers have a lot of memory I have not experimented with the
possible memory optimizations which could be made to this code. However, there
are two changes which could be made. The first is that the
<code class="code docutils literal notranslate"><span class="pre">init_fir_stream</span></code> function could store the pointer its given to
<code class="code docutils literal notranslate"><span class="pre">taps</span></code> rather than making a copy. This would reduce the memory footprint
of the FIR filter at the expense of thread safety in multithreaded programs.
Secondly, the <code class="code docutils literal notranslate"><span class="pre">buffer</span></code> element in <code class="code docutils literal notranslate"><span class="pre">FIR_Stream_Mem</span></code> is currently one
byte longer than it needs to be - the final element is never used as part of
the filter. This could be fixed, but it would make the indexing in
<code class="code docutils literal notranslate"><span class="pre">apply_fft</span></code> a bit more complicated.</p>
</section>
<section id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this heading">¶</a></h2>
<p>We have explored ways in which the FIR filter implementation can be optimized
for both speed and memory usage. In the next section we will look at extending
the filter to integer and complex data types.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
    
        <div id="show_right_sidebar">
            <p><a class="toggle_right_sidebar" href="#"><span class="icon">&lt;</span><span>Page contents<span></a></p>
        </div>

        <div id="right_sidebar">
            <p><a class="toggle_right_sidebar" href="#"><span class="icon">&gt;</span><span>Page contents:<span></a></p>
            <div class="page_toc">
                <ul>
<li><a class="reference internal" href="#">Writing a Basic FIR Filter in C (2)</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#speed-optimizations">Speed optimizations</a><ul>
<li><a class="reference internal" href="#speed-boost">Speed Boost</a></li>
</ul>
</li>
<li><a class="reference internal" href="#memory-optimizations">Memory optimizations</a></li>
<li><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
</ul>

            </div>
        </div>
    

      <div class="clearer"></div>
    </div>
    <div class="button_nav_wrapper">
        <div class="button_nav">
            <div class="left">
                
                <a href="fir_filter_in_c_1.html">
                    <span class="icon">&lt;</span><span>Writing a Basic FIR Filter in C (1)</span></a>
                
            </div>

            <div class="right">
                
            </div>
        </div>
    </div>


    <div class="footer" role="contentinfo">
        &#169; Copyright 2023, Sam G.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.1.3.
    </div>

<p id="theme_credit">Styled using the <a href="https://github.com/piccolo-orm/piccolo_theme">Piccolo Theme</a></p>
  </body>
</html>