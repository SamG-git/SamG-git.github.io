Emulating the RP2040 with Ghidra
================================

Ghidra (an open-source SRE framework written by the NSA) provides a featureful emulator which works on all the achitectures Ghidra supports. These notes will show how to emulate a basic RP2040 ELF.

Prerequisites
-------------

In order to follow these notes, both the latest version of Ghidra and the RP2040 SDK must be installed. Resources on how to do this can be found here:

* `Install Ghidra <https://ghidra-sre.org/InstallationGuide.html>`
* `Install RP2040 SDK <https://datasheets.raspberrypi.com/pico/getting-started-with-pico.pdf>`

Building Hello World
--------------------

The first binary I attempted to emulate was a basic Hello World script consisting of the following main function:

.. code-block:: C

    #include <stdio.h>
    #include "pico/stdlib.h"

    int main() {
        stdio_init_all();
        for(int i = 0; i < 10; i++) {
            printf("Hello, world!\n");
            sleep_ms(1000);
        }
    }

I configures the CMakeLists.txt file to output only on the USB interface using the following:

.. code-block:: cmake

    cmake_minimum_required(VERSION 3.13)

    include(pico_sdk_import.cmake)

    project(hello_serial C CXX ASM)
    set(CMAKE_C_STANDARD 11)
    set(CMAKE_CXX_STANDARD 17)

    pico_sdk_init()

    if (TARGET tinyusb_device)
        add_executable(pico_hello
                hello_serial.c
                )

        # pull in common dependencies
        target_link_libraries(pico_hello pico_stdlib)

        # enable usb output, disable uart output
        pico_enable_stdio_usb(pico_hello 1)
        pico_enable_stdio_uart(pico_hello 0)

        # create map/bin/hex/uf2 file etc.
        pico_add_extra_outputs(pico_hello)

    elseif(PICO_ON_DEVICE)
        message(WARNING "not building hello_usb because TinyUSB submodule is not initialized in the SDK")
    endif()

Attempting to Emulate Main
--------------------------

Once the code had been compiled, I started a new Ghidra project and imported the ELF file. I then ran Ghidra's automated analysis tools and had a quick look through the decompiled code. 

Initially, I attempted to emulate main by running the following Ghidra script:

.. code-block:: python

    from ghidra.app.emulator import EmulatorHelper
    from ghidra.program.model.symbol import SymbolUtilities


    def getAddress(offset):
        return currentProgram.getAddressFactory().getDefaultAddressSpace().getAddress(offset)

    def getSymbolAddress(symbolName):
        symbol = SymbolUtilities.getLabelOrFunctionSymbol(currentProgram, symbolName, None)
        if (symbol != None):
            return symbol.getAddress()
        else:
            raise("Failed to locate label: {}".format(symbolName))

    def getProgramRegisterList(currentProgram):
        pc = currentProgram.getProgramContext()
        return pc.registers

    def main():
        CONTROLLED_RETURN_OFFSET = 0

        mainFunctionEntry = getSymbolAddress("main")
        emuHelper = EmulatorHelper(currentProgram)
        controlledReturnAddr = getAddress(CONTROLLED_RETURN_OFFSET)

        # Tell emulator to run the main() function
        mainFunctionEntryLong = int("0x{}".format(mainFunctionEntry), 16)
        emuHelper.writeRegister(emuHelper.getPCRegister(), mainFunctionEntryLong)
                    
        print("Emulation starting at 0x{}".format(mainFunctionEntry))
        while monitor.isCancelled() is False:
            
            executionAddress = emuHelper.getExecutionAddress()  
            if (executionAddress == controlledReturnAddr):
                print("Emulation complete.")
                return

            print("Address: 0x{} ({})".format(executionAddress, getInstructionAt(executionAddress)))

            # single step emulation
            success = emuHelper.step(monitor)
            if (success == False):
                lastError = emuHelper.getLastError()
                printerr("Emulation Error: '{}'".format(lastError))
                return

        emuHelper.dispose()

    main()

This gave the following output:

.. code-block::

    Emulation starting at 0x1000035c
    Address: 0x1000035c (push {r4,lr})
    Address: 0x1000035e (bl 0x100045ec)
    Address: 0x100045ec (push {r4,lr})
    Address: 0x100045ee (bl 0x10004898)
    Address: 0x10004898 (push {r4,r5,r6,lr})
    Address: 0x1000489a (sub sp,#0x10)
    Address: 0x1000489c (movs r3,#0xd0)
    Address: 0x1000489e (lsls r3,r3,#0x18)
    Address: 0x100048a0 (ldrb r2,[r3,#0x0])
    Address: 0x100048a2 (ldr r3,[0x10004958])
    Address: 0x100048a4 (strb r2,[r3,#0x0])
    Address: 0x100048a6 (ldr r3,[0x1000495c])
    Address: 0x100048a8 (ldrb r3,[r3,#0x0])
    Address: 0x100048aa (bl 0x100069cc)
    Address: 0x100069cc (push {r4,lr})
    Address: 0x100069ce (movs r0,#0x0)
    Address: 0x100069d0 (bl 0x100054c8)
    Address: 0x100054c8 (push {r4,r5,r6,lr})
    Address: 0x100054ca (movs r5,r0)
    Address: 0x100054cc (ldr r3,[0x1000556c])
    Address: 0x100054ce (ldrb r0,[r3,#0x0])
    Address: 0x100054d0 (cmp r0,#0x0)
    Address: 0x100054d2 (beq 0x100054d6)
    Address: 0x100054d6 (movs r2,#0x53)
    Address: 0x100054d8 (movs r1,#0x0)
    Address: 0x100054da (ldr r0,[0x10005570])
    Address: 0x100054dc (bl 0x10004340)
    Address: 0x10004340 (ldr r3,[0x10004348])
    Address: 0x10004342 (ldr r3,[r3,#0x0])
    Address: 0x10004344 (bx r3)
    Address: 0x0000534c (None)
    emulate_rp2040.py> Emulation Error: 'Instruction decode failed (Bytes do not form a legal instruction.), PC=0000534c'

By analysing the decompiled binary I could see that the following function calls were made before the error happened: main() > stdio_init_all() > stdio_usb_init() > tusb_init() > tud_init() > __wrap_memset(void)

The __wrap_memset(void) function decompiles to this:

.. code-block:: C

    _Bool tud_init(uint8_t rhport)

    {
        ...
        __wrap_memset(&_usb_dev,0,0x53);
        ...
    }

    void __wrap_memset(void)

    {
                        /* WARNING: Treating indirect jump as call */
        (*(code *)0x534d)();
        return;
    }

The emulator is unable to find valid instructions at address 0x534d and therefore throws an error. By looking at the RP2040 datasheet we can see that the first 16kB of memory, starting at address 0x00000000, is the ROM fixed at the time of silicon manufacture. Therefore, it would seem that the program is trying to execute some code baked into the ROM. 
